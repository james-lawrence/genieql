package genieql

import (
	"log"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/pkg/errors"
	"gopkg.in/yaml.v3"
)

// Configuration main configuration for genieql. usually generated by the Bootstrap
// function.
type Configuration struct {
	Location      string `yaml:"-"`
	Name          string
	Dialect       string
	Driver        string
	Queryer       string
	RowType       string
	ConnectionURL string
	Host          string
	Port          int
	Database      string
	Username      string
	Password      string
}

// ReadMap the column -> struct mapping from disk cache.
func (t Configuration) ReadMap(m *MappingConfig, options ...MappingConfigOption) error {
	m.Apply(options...)
	return ReadMapper(t, "default", m)
}

// WriteMap persists the column -> struct mapping to disk cache.
func (t Configuration) WriteMap(m MappingConfig) error {
	return WriteMapper(t, "default", m)
}

// Bootstrap takes a db connection url and creates a genieql
// configuration from the url and writes out the configuration to the provided
// path.
func Bootstrap(options ...ConfigurationOption) error {
	var (
		err    error
		config Configuration
	)

	if config, err = NewConfiguration(options...); err != nil {
		return err
	}

	if err := os.MkdirAll(config.Location, 0755); err != nil {
		return errors.Wrap(err, "failed to make bootstrap directory")
	}

	return WriteConfiguration(config)
}

// WriteConfiguration writes the genieql configuration file to the specified path.
func WriteConfiguration(config Configuration) error {
	var (
		err error
		raw []byte
	)

	if raw, err = yaml.Marshal(config); err != nil {
		return errors.Wrap(err, "failed to serialize configuration to yaml")
	}

	return errors.Wrap(os.WriteFile(filepath.Join(config.Location, config.Name), raw, 0666), "failed to persist configuration to disk")
}

// ReadConfiguration reads the genieql configuration file from the specified path.
func ReadConfiguration(config *Configuration, options ...ConfigurationOption) error {
	var (
		err error
		raw []byte
	)

	if raw, err = os.ReadFile(filepath.Join(config.Location, config.Name)); err != nil {
		return errors.Wrap(err, "failed to read configuration file")
	}

	if err = yaml.Unmarshal(raw, config); err != nil {
		return errors.Wrap(err, "failed to parse configuration file")
	}

	return nil
}

// MustConfiguration builds a configuration from the provided options.
func MustConfiguration(c Configuration, err error) Configuration {
	if err != nil {
		log.Fatalf("%+v\n", err)
	}

	return c
}

// MustReadConfiguration builds a new configuration from the provided options,
// and read's it from disk.
func MustReadConfiguration(options ...ConfigurationOption) Configuration {
	c := MustConfiguration(NewConfiguration(options...))
	if e := ReadConfiguration(&c); e != nil {
		log.Fatalf("%+v\n", e)
	}
	return c
}

// NewConfiguration builds a configuration from the provided options.
func NewConfiguration(options ...ConfigurationOption) (Configuration, error) {
	var (
		config = Configuration{
			Queryer: "*sql.DB",
			RowType: "*sql.Row",
		}
	)

	return config.Clone(options...)
}

func (t Configuration) Clone(options ...ConfigurationOption) (Configuration, error) {
	for _, opt := range options {
		if err := opt(&t); err != nil {
			return t, err
		}
	}

	return t, nil
}

// ConfigurationOption options for creating a Configuration
type ConfigurationOption func(*Configuration) error

// ConfigurationOptionLocation specify the absolute path of the configuration file.
func ConfigurationOptionLocation(path string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Location, c.Name = filepath.Dir(path), filepath.Base(path)
		return nil
	}
}

// ConfigurationOptionQueryer specify the default queryer to use.
func ConfigurationOptionQueryer(queryer string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Queryer = queryer
		return nil
	}
}

// ConfigurationOptionRowType specify the default type to use for static row scanners.
func ConfigurationOptionRowType(rt string) ConfigurationOption {
	return func(c *Configuration) error {
		c.RowType = rt
		return nil
	}
}

// ConfigurationOptionDatabase specify the database connection information.
func ConfigurationOptionDatabase(uri *url.URL) ConfigurationOption {
	return func(c *Configuration) (err error) {
		var (
			host  string
			sport string
			port  int
		)
		splits := strings.Split(uri.Host, ":")
		switch len(splits) {
		case 2:
			host, sport = splits[0], splits[1]
			port, err = strconv.Atoi(sport)
			if err != nil {
				return err
			}
		case 1:
			host = uri.Host
		}

		c.ConnectionURL = uri.String()
		c.Dialect = uri.Scheme
		c.Host = host
		c.Port = port
		c.Database = strings.Trim(uri.Path, "/")
		c.Username = uri.User.Username()
		c.Password, _ = uri.User.Password()
		return nil
	}
}

// ConfigurationOptionDriver specify the driver for the configuration.
func ConfigurationOptionDriver(driver string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Driver = driver
		return nil
	}
}

// ConfigurationOptionDialect specify the dialect
func ConfigurationOptionDialect(d string) ConfigurationOption {
	return func(c *Configuration) error {
		c.Dialect = d
		return nil
	}
}
