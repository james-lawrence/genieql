//go:build !genieql.ignore
// +build !genieql.ignore

package pkgc

import (
	"database/sql"
	"math"
	"time"

	"github.com/jackc/pgtype"
	"github.com/james-lawrence/genieql/examples/postgresql/autocompilegraph/pkga"
	"github.com/james-lawrence/genieql/examples/postgresql/autocompilegraph/pkgb"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql -test.testlogfile=/var/folders/qv/04st9vg169b_4zvq86mv7kjw0000gn/T/go-build3643822935/b001/testlog.txt -test.paniconexit0 -test.v=true -test.run=TestAutoCompileGraph_Integration_ThreeLevelDependencies -test.timeout=30s

// PackageCExample generated by genieql
type PackageCExample struct {
	ID int
}

// PackageCScanner scanner interface.
type PackageCScanner interface {
	Scan(a *pkga.PackageAExample, b *pkgb.PackageBExample) error
	Next() bool
	Close() error
	Err() error
}

type errPackageCScanner struct {
	e error
}

func (t errPackageCScanner) Scan(a *pkga.PackageAExample, b *pkgb.PackageBExample) error {
	return t.e
}

func (t errPackageCScanner) Next() bool {
	return false
}

func (t errPackageCScanner) Err() error {
	return t.e
}

func (t errPackageCScanner) Close() error {
	return nil
}

// NewPackageCScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewPackageCScannerStatic(rows *sql.Rows, err error) PackageCScanner {
	if err != nil {
		return errPackageCScanner{e: err}
	}

	return packageCScannerStatic{
		Rows: rows,
	}
}

// packageCScannerStatic generated by genieql
type packageCScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t packageCScannerStatic) Scan(a *pkga.PackageAExample, b *pkgb.PackageBExample) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
		c26 pgtype.Bool
		c27 pgtype.Int4Array
		c28 pgtype.Int8Array
		c29 pgtype.Text
		c30 pgtype.Timestamptz
		c31 pgtype.UUIDArray
		c32 pgtype.UUID
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25, &c26, &c27, &c28, &c29, &c30, &c31, &c32); err != nil {
		return err
	}

	if err := c0.AssignTo(&a.BigintField); err != nil {
		return err
	}

	if err := c1.AssignTo(&a.BitField); err != nil {
		return err
	}

	if err := c2.AssignTo(&a.BitVaryingField); err != nil {
		return err
	}

	if err := c3.AssignTo(&a.BoolField); err != nil {
		return err
	}

	if err := c4.AssignTo(&a.ByteArrayField); err != nil {
		return err
	}

	if err := c5.AssignTo(&a.CharacterField); err != nil {
		return err
	}

	if err := c6.AssignTo(&a.CharacterFixedField); err != nil {
		return err
	}

	if err := c7.AssignTo(&a.CidrField); err != nil {
		return err
	}

	if err := c8.AssignTo(&a.DecimalField); err != nil {
		return err
	}

	if err := c9.AssignTo(&a.DoublePrecisionField); err != nil {
		return err
	}

	if err := c10.AssignTo(&a.InetField); err != nil {
		return err
	}

	if err := c11.AssignTo(&a.Int2Array); err != nil {
		return err
	}

	if err := c12.AssignTo(&a.Int4Array); err != nil {
		return err
	}

	if err := c13.AssignTo(&a.Int8Array); err != nil {
		return err
	}

	if err := c14.AssignTo(&a.IntField); err != nil {
		return err
	}

	if err := c15.AssignTo(&a.IntervalField); err != nil {
		return err
	}

	if err := c16.AssignTo(&a.JSONField); err != nil {
		return err
	}

	if err := c17.AssignTo(&a.JsonbField); err != nil {
		return err
	}

	if err := c18.AssignTo(&a.MacaddrField); err != nil {
		return err
	}

	if err := c19.AssignTo(&a.NumericField); err != nil {
		return err
	}

	if err := c20.AssignTo(&a.RealField); err != nil {
		return err
	}

	if err := c21.AssignTo(&a.SmallintField); err != nil {
		return err
	}

	if err := c22.AssignTo(&a.TextField); err != nil {
		return err
	}

	switch c23.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		a.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		a.TimestampField = tmp
	default:
		if err := c23.AssignTo(&a.TimestampField); err != nil {
			return err
		}
	}

	if err := c24.AssignTo(&a.UUIDArray); err != nil {
		return err
	}

	if err := c25.AssignTo(&a.UUIDField); err != nil {
		return err
	}

	if err := c26.AssignTo(&b.BoolField); err != nil {
		return err
	}

	if err := c27.AssignTo(&b.Int4Array); err != nil {
		return err
	}

	if err := c28.AssignTo(&b.Int8Array); err != nil {
		return err
	}

	if err := c29.AssignTo(&b.TextField); err != nil {
		return err
	}

	switch c30.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		b.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		b.TimestampField = tmp
	default:
		if err := c30.AssignTo(&b.TimestampField); err != nil {
			return err
		}
	}

	if err := c31.AssignTo(&b.UUIDArray); err != nil {
		return err
	}

	if err := c32.AssignTo(&b.UUIDField); err != nil {
		return err
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t packageCScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t packageCScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t packageCScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewPackageCScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewPackageCScannerStaticRow(row *sql.Row) PackageCScannerStaticRow {
	return PackageCScannerStaticRow{
		row: row,
	}
}

// PackageCScannerStaticRow generated by genieql
type PackageCScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t PackageCScannerStaticRow) Scan(a *pkga.PackageAExample, b *pkgb.PackageBExample) error {
	var (
		c0  pgtype.Int8
		c1  pgtype.Bit
		c2  pgtype.Varbit
		c3  pgtype.Bool
		c4  pgtype.Bytea
		c5  pgtype.Varchar
		c6  pgtype.BPChar
		c7  pgtype.CIDR
		c8  pgtype.Numeric
		c9  pgtype.Float8
		c10 pgtype.Inet
		c11 pgtype.Int2Array
		c12 pgtype.Int4Array
		c13 pgtype.Int8Array
		c14 pgtype.Int4
		c15 pgtype.Interval
		c16 pgtype.JSON
		c17 pgtype.JSONB
		c18 pgtype.Macaddr
		c19 pgtype.Numeric
		c20 pgtype.Float4
		c21 pgtype.Int2
		c22 pgtype.Text
		c23 pgtype.Timestamptz
		c24 pgtype.UUIDArray
		c25 pgtype.UUID
		c26 pgtype.Bool
		c27 pgtype.Int4Array
		c28 pgtype.Int8Array
		c29 pgtype.Text
		c30 pgtype.Timestamptz
		c31 pgtype.UUIDArray
		c32 pgtype.UUID
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7, &c8, &c9, &c10, &c11, &c12, &c13, &c14, &c15, &c16, &c17, &c18, &c19, &c20, &c21, &c22, &c23, &c24, &c25, &c26, &c27, &c28, &c29, &c30, &c31, &c32); err != nil {
		return err
	}

	if err := c0.AssignTo(&a.BigintField); err != nil {
		return err
	}

	if err := c1.AssignTo(&a.BitField); err != nil {
		return err
	}

	if err := c2.AssignTo(&a.BitVaryingField); err != nil {
		return err
	}

	if err := c3.AssignTo(&a.BoolField); err != nil {
		return err
	}

	if err := c4.AssignTo(&a.ByteArrayField); err != nil {
		return err
	}

	if err := c5.AssignTo(&a.CharacterField); err != nil {
		return err
	}

	if err := c6.AssignTo(&a.CharacterFixedField); err != nil {
		return err
	}

	if err := c7.AssignTo(&a.CidrField); err != nil {
		return err
	}

	if err := c8.AssignTo(&a.DecimalField); err != nil {
		return err
	}

	if err := c9.AssignTo(&a.DoublePrecisionField); err != nil {
		return err
	}

	if err := c10.AssignTo(&a.InetField); err != nil {
		return err
	}

	if err := c11.AssignTo(&a.Int2Array); err != nil {
		return err
	}

	if err := c12.AssignTo(&a.Int4Array); err != nil {
		return err
	}

	if err := c13.AssignTo(&a.Int8Array); err != nil {
		return err
	}

	if err := c14.AssignTo(&a.IntField); err != nil {
		return err
	}

	if err := c15.AssignTo(&a.IntervalField); err != nil {
		return err
	}

	if err := c16.AssignTo(&a.JSONField); err != nil {
		return err
	}

	if err := c17.AssignTo(&a.JsonbField); err != nil {
		return err
	}

	if err := c18.AssignTo(&a.MacaddrField); err != nil {
		return err
	}

	if err := c19.AssignTo(&a.NumericField); err != nil {
		return err
	}

	if err := c20.AssignTo(&a.RealField); err != nil {
		return err
	}

	if err := c21.AssignTo(&a.SmallintField); err != nil {
		return err
	}

	if err := c22.AssignTo(&a.TextField); err != nil {
		return err
	}

	switch c23.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		a.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		a.TimestampField = tmp
	default:
		if err := c23.AssignTo(&a.TimestampField); err != nil {
			return err
		}
	}

	if err := c24.AssignTo(&a.UUIDArray); err != nil {
		return err
	}

	if err := c25.AssignTo(&a.UUIDField); err != nil {
		return err
	}

	if err := c26.AssignTo(&b.BoolField); err != nil {
		return err
	}

	if err := c27.AssignTo(&b.Int4Array); err != nil {
		return err
	}

	if err := c28.AssignTo(&b.Int8Array); err != nil {
		return err
	}

	if err := c29.AssignTo(&b.TextField); err != nil {
		return err
	}

	switch c30.InfinityModifier {
	case pgtype.Infinity:
		tmp := time.Unix(math.MaxInt64-62135596800, 999999999)
		b.TimestampField = tmp
	case pgtype.NegativeInfinity:
		tmp := time.Unix(math.MinInt64, math.MinInt64)
		b.TimestampField = tmp
	default:
		if err := c30.AssignTo(&b.TimestampField); err != nil {
			return err
		}
	}

	if err := c31.AssignTo(&b.UUIDArray); err != nil {
		return err
	}

	if err := c32.AssignTo(&b.UUIDField); err != nil {
		return err
	}

	return nil
}

// Err set an error to return by scan
func (t PackageCScannerStaticRow) Err(err error) PackageCScannerStaticRow {
	t.err = err
	return t
}


