//go:build !genieql.ignore
// +build !genieql.ignore

package pkgd

import (
	"database/sql"

	"github.com/jackc/pgtype"
	"github.com/james-lawrence/genieql/examples/postgresql/autocompilegraph/pkgc"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto graph --config=postgresql.test.config -o genieql.gen.go

// PackageDExample generated by genieql
type PackageDExample struct {
	ID int
}

// PackageDScanner scanner interface.
type PackageDScanner interface {
	Scan(c *pkgc.PackageCExample) error
	Next() bool
	Close() error
	Err() error
}

type errPackageDScanner struct {
	e error
}

func (t errPackageDScanner) Scan(c *pkgc.PackageCExample) error {
	return t.e
}

func (t errPackageDScanner) Next() bool {
	return false
}

func (t errPackageDScanner) Err() error {
	return t.e
}

func (t errPackageDScanner) Close() error {
	return nil
}

// PackageDScannerStaticColumns generated by genieql
const PackageDScannerStaticColumns = `"id"`

// NewPackageDScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewPackageDScannerStatic(rows *sql.Rows, err error) PackageDScanner {
	if err != nil {
		return errPackageDScanner{e: err}
	}

	return packageDScannerStatic{
		Rows: rows,
	}
}

// packageDScannerStatic generated by genieql
type packageDScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t packageDScannerStatic) Scan(c *pkgc.PackageCExample) error {
	var (
		c0 pgtype.Int4
	)

	if err := t.Rows.Scan(&c0); err != nil {
		return err
	}

	if err := c0.AssignTo(&c.ID); err != nil {
		return err
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t packageDScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t packageDScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t packageDScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewPackageDScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewPackageDScannerStaticRow(row *sql.Row) PackageDScannerStaticRow {
	return PackageDScannerStaticRow{
		row: row,
	}
}

// PackageDScannerStaticRow generated by genieql
type PackageDScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t PackageDScannerStaticRow) Scan(c *pkgc.PackageCExample) error {
	var (
		c0 pgtype.Int4
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0); err != nil {
		return err
	}

	if err := c0.AssignTo(&c.ID); err != nil {
		return err
	}

	return nil
}

// Err set an error to return by scan
func (t PackageDScannerStaticRow) Err(err error) PackageDScannerStaticRow {
	t.err = err
	return t
}

// NewPackageDScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewPackageDScannerDynamic(rows *sql.Rows, err error) PackageDScanner {
	if err != nil {
		return errPackageDScanner{e: err}
	}

	return packageDScannerDynamic{
		Rows: rows,
	}
}

// packageDScannerDynamic generated by genieql
type packageDScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t packageDScannerDynamic) Scan(c *pkgc.PackageCExample) error {
	const (
		cn0 = "id"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      pgtype.Int4
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if err := c0.AssignTo(&c.ID); err != nil {
				return err
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t packageDScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t packageDScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t packageDScannerDynamic) Next() bool {
	return t.Rows.Next()
}


