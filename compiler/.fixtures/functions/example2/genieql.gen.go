//go:build !genieql.ignore
// +build !genieql.ignore

package example2

import (
	"database/sql"
	"time"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql

// Example1 generated by genieql
type Example1 struct {
	BigintField         int64
	BoolField           bool
	CharacterField      string
	CharacterFixedField string
	IntField            int32
	SmallintField       int16
	TextField           string
	TimestampField      time.Time
}

// Example2 generated by genieql
type Example2 struct {
	BoolField      bool
	TextField      string
	TimestampField time.Time
}

// Example1Scanner scanner interface.
type Example1Scanner interface {
	Scan(i *Example1) error
	Next() bool
	Close() error
	Err() error
}

type errExample1Scanner struct {
	e error
}

func (t errExample1Scanner) Scan(i *Example1) error {
	return t.e
}

func (t errExample1Scanner) Next() bool {
	return false
}

func (t errExample1Scanner) Err() error {
	return t.e
}

func (t errExample1Scanner) Close() error {
	return nil
}

// Example1ScannerStaticColumns generated by genieql
const Example1ScannerStaticColumns = `"bigint_field","bool_field","character_field","character_fixed_field","int_field","smallint_field","text_field","timestamp_field"`

// NewExample1ScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewExample1ScannerStatic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerStatic{
		Rows: rows,
	}
}

// example1ScannerStatic generated by genieql
type example1ScannerStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example1ScannerStatic) Scan(i *Example1) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullBool
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullInt32
		c5 sql.NullInt16
		c6 sql.NullString
		c7 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7); err != nil {
		return err
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example1ScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example1ScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example1ScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewExample1ScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewExample1ScannerStaticRow(row *sql.Row) Example1ScannerStaticRow {
	return Example1ScannerStaticRow{
		row: row,
	}
}

// Example1ScannerStaticRow generated by genieql
type Example1ScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t Example1ScannerStaticRow) Scan(i *Example1) error {
	var (
		c0 sql.NullInt64
		c1 sql.NullBool
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullInt32
		c5 sql.NullInt16
		c6 sql.NullString
		c7 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7); err != nil {
		return err
	}

	return nil
}

// Err set an error to return by scan
func (t Example1ScannerStaticRow) Err(err error) Example1ScannerStaticRow {
	t.err = err
	return t
}

// NewExample1ScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewExample1ScannerDynamic(rows *sql.Rows, err error) Example1Scanner {
	if err != nil {
		return errExample1Scanner{e: err}
	}

	return example1ScannerDynamic{
		Rows: rows,
	}
}

// example1ScannerDynamic generated by genieql
type example1ScannerDynamic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t example1ScannerDynamic) Scan(i *Example1) error {
	const (
		cn0 = "bigint_field"
		cn1 = "bool_field"
		cn2 = "character_field"
		cn3 = "character_fixed_field"
		cn4 = "int_field"
		cn5 = "smallint_field"
		cn6 = "text_field"
		cn7 = "timestamp_field"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullInt64
		c1      sql.NullBool
		c2      sql.NullString
		c3      sql.NullString
		c4      sql.NullInt32
		c5      sql.NullInt16
		c6      sql.NullString
		c7      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:

		case cn1:

		case cn2:

		case cn3:

		case cn4:

		case cn5:

		case cn6:

		case cn7:

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t example1ScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t example1ScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t example1ScannerDynamic) Next() bool {
	return t.Rows.Next()
}
