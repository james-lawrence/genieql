package generated

import (
	"database/sql"
	"net"

	"github.com/jackc/pgx/v5/pgtype"
)

// IPNetArray scanner interface.
type IPNetArray interface {
	Scan(arg1 *[]net.IPNet) error
	Next() bool
	Close() error
	Err() error
}

type errIPNetArray struct {
	e error
}

func (t errIPNetArray) Scan(arg1 *[]net.IPNet) error {
	return t.e
}

func (t errIPNetArray) Next() bool {
	return false
}

func (t errIPNetArray) Err() error {
	return t.e
}

func (t errIPNetArray) Close() error {
	return nil
}

// IPNetArrayStaticColumns generated by genieql
const IPNetArrayStaticColumns = `"arg1"`

// NewIPNetArrayStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewIPNetArrayStatic(rows *sql.Rows, err error) IPNetArray {
	if err != nil {
		return errIPNetArray{e: err}
	}

	return iPNetArrayStatic{
		Rows: rows,
	}
}

// iPNetArrayStatic generated by genieql
type iPNetArrayStatic struct {
	Rows *sql.Rows
}

// Scan generated by genieql
func (t iPNetArrayStatic) Scan(arg1 *[]net.IPNet) error {
	var (
		c0 pgtype.CIDRArray
	)

	if err := t.Rows.Scan(&c0); err != nil {
		return err
	}

	if err := c0.AssignTo(arg1); err != nil {
		return err
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t iPNetArrayStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t iPNetArrayStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t iPNetArrayStatic) Next() bool {
	return t.Rows.Next()
}

// NewIPNetArrayStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewIPNetArrayStaticRow(row *sql.Row) IPNetArrayStaticRow {
	return IPNetArrayStaticRow{
		row: row,
	}
}

// IPNetArrayStaticRow generated by genieql
type IPNetArrayStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t IPNetArrayStaticRow) Scan(arg1 *[]net.IPNet) error {
	var (
		c0 pgtype.CIDRArray
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0); err != nil {
		return err
	}

	if err := c0.AssignTo(arg1); err != nil {
		return err
	}

	return nil
}

// Err set an error to return by scan
func (t IPNetArrayStaticRow) Err(err error) IPNetArrayStaticRow {
	t.err = err
	return t
}
