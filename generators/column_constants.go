package generators

import (
	"go/ast"
	"go/build"
	"go/types"
	"io"
	"strings"
	"text/template"

	"github.com/pkg/errors"

	"github.com/james-lawrence/genieql"
)

// ColumnConstantContext for building column sets.
// TODO consider turning this into a general generator context.
type ColumnConstantContext struct {
	Config  genieql.Configuration
	Package *build.Package
}

// NewColumnConstantFromFieldList generates column constants from field list.
func NewColumnConstantFromFieldList(ctx Context, name string, trans genieql.ColumnTransformer, fields *ast.FieldList, ignoreset ...string) genieql.Generator {
	var (
		infos []genieql.ColumnInfo
	)

	for _, param := range fields.List {
		i, err := columnInfo(ctx, param)
		if err != nil {
			return genieql.NewErrGenerator(err)
		}
		infos = append(infos, i...)
	}
	return NewColumnConstants(name, trans, infos)
}

// NewColumnConstants builds a generator from a set of ColumnInfo.
func NewColumnConstants(name string, trans genieql.ColumnTransformer, columns []genieql.ColumnInfo) genieql.Generator {
	return constants{
		Name:        name,
		Columns:     columns,
		Transformer: trans,
	}
}

type constants struct {
	Name        string
	Columns     []genieql.ColumnInfo
	Transformer genieql.ColumnTransformer
}

func (t constants) Generate(dst io.Writer) error {
	const (
		templatename            = "column-constants"
		columnConstantsTemplate = `
// {{.Name}} generated by genieql
const {{.Name}} = ` + "`{{ .Columns | transform | columns}}`"
	)
	type context struct {
		Name    string
		Columns []genieql.ColumnInfo
	}
	var (
		err error
		ctx = context{
			Name:    t.Name,
			Columns: t.Columns,
		}
	)

	funcMap := template.FuncMap{
		"transform": transformer{ColumnTransformer: t.Transformer}.transform,
		"columns": func(i []string) string {
			return strings.Join(i, ",")
		},
	}

	tmpl := template.Must(template.New(templatename).Funcs(funcMap).Parse(columnConstantsTemplate))
	if err = tmpl.Execute(dst, ctx); err != nil {
		return errors.Wrap(err, "failed to generate columns constant")
	}

	_, err = dst.Write([]byte("\n"))

	return errors.Wrap(err, "")
}

type transformer struct {
	genieql.ColumnTransformer
}

func (t transformer) transform(m []genieql.ColumnInfo) []string {
	s := make([]string, 0, len(m))
	for _, c := range m {
		tmp := t.ColumnTransformer.Transform(c)
		s = append(s, tmp)
	}
	return s
}

func columnInfo(ctx Context, param *ast.Field) ([]genieql.ColumnInfo, error) {
	if builtinType(param.Type) {
		return builtinParamColumnInfo(ctx, param)
	}
	_, info, err := mappedParam(ctx, param)
	return info, err
}

// builtinParamColumnInfo converts a *ast.Field that represents a builtin type
// (time.Time,int,float,bool, etc) into an array of ColumnInfo.
func builtinParamColumnInfo(ctx Context, param *ast.Field) (columns []genieql.ColumnInfo, err error) {
	columns = make([]genieql.ColumnInfo, 0, len(param.Names))
	for _, name := range param.Names {
		d, missing := ctx.Driver.LookupType(types.ExprString(param.Type))
		if missing != nil {
			return columns, err
		}

		columns = append(columns, genieql.ColumnInfo{
			Name:       name.Name,
			Definition: d,
		})
	}

	return columns, err
}
