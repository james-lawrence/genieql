package generators

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"path/filepath"

	"github.com/james-lawrence/genieql"
	"github.com/james-lawrence/genieql/astcodec"
	"github.com/james-lawrence/genieql/astutil"
	"github.com/james-lawrence/genieql/dialects"
	"github.com/james-lawrence/genieql/internal/drivers"
	"github.com/james-lawrence/genieql/internal/errorsx"
	"github.com/james-lawrence/genieql/internal/md5x"
	"github.com/james-lawrence/genieql/internal/userx"
)

// Logging levels
const (
	VerbosityError = iota
	VerbosityWarn
	VerbosityInfo
	VerbosityDebug
	VerbosityTrace
)

// Context - context for generators
type Context struct {
	Name           string
	ModuleRoot     string
	Cache          string
	Build          build.Context
	CurrentPackage *build.Package
	FileSet        *token.FileSet
	Configuration  genieql.Configuration
	Dialect        genieql.Dialect
	Driver         genieql.Driver
	Verbosity      int
	OSArgs         []string
}

// Println ...
func (t Context) Println(args ...interface{}) {
	if t.Verbosity < VerbosityInfo {
		return
	}

	errorsx.MaybePanic(log.Output(2, fmt.Sprintln(args...)))
}

// Printf ...
func (t Context) Printf(format string, args ...interface{}) {
	if t.Verbosity < VerbosityInfo {
		return
	}

	errorsx.MaybePanic(log.Output(2, fmt.Sprintf(format, args...)))
}

// Debug logs
func (t Context) Debug(args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	errorsx.MaybePanic(log.Output(2, fmt.Sprint(args...)))
}

// Debugf logs
func (t Context) Debugf(format string, args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	errorsx.MaybePanic(log.Output(2, fmt.Sprintf(format, args...)))
}

// Debugln logs
func (t Context) Debugln(args ...interface{}) {
	if t.Verbosity < VerbosityDebug {
		return
	}

	errorsx.MaybePanic(log.Output(2, fmt.Sprintln(args...)))
}

// Traceln detailed logging
func (t Context) Traceln(args ...interface{}) {
	if t.Verbosity < VerbosityTrace {
		return
	}

	errorsx.MaybePanic(log.Output(2, fmt.Sprintln(args...)))
}

func reserved(s string) bool {
	switch s {
	case "type":
		return true
	case "func":
		return true
	case "default":
		return true
	default:
		return false
	}
}

var (
	queryPattern    = astutil.TypePattern(astutil.ExprTemplateList("*sql.Rows", "error")...)
	queryRowPattern = astutil.TypePattern(astutil.ExprTemplateList("*sql.Row")...)
)

// GenerateComment generates a comment.
func GenerateComment(comments ...*ast.CommentGroup) genieql.Generator {
	doc := mergeComments(comments...)
	return genieql.NewFuncGenerator(func(dst io.Writer) (err error) {
		for _, c := range doc.List {
			if _, err = dst.Write([]byte(c.Text)); err != nil {
				return err
			}

			if _, err = dst.Write([]byte("\n")); err != nil {
				return err
			}
		}

		return nil
	})
}

func GapLines(dst io.Writer, n int) (err error) {
	for i := 0; i < n; i++ {
		if _, err = fmt.Fprintln(dst); err != nil {
			return err
		}
	}

	return nil
}

func DefaultFunctionComment(name string) *ast.CommentGroup {
	return &ast.CommentGroup{
		List: []*ast.Comment{
			{Text: fmt.Sprintf("// %s generated by genieql", name)},
		},
	}
}

func mergeComments(comments ...*ast.CommentGroup) (m *ast.CommentGroup) {
	switch len(comments) {
	case 0:
		return nil
	case 1:
		return comments[0]
	default:
		for _, c := range comments {
			if c == nil {
				continue
			}

			if m == nil {
				m = c
				continue
			}

			m.List = append(m.List, c.List...)
		}

		return m
	}
}

type Option func(*Context)

func OptionOSArgs(args ...string) Option {
	return func(ctx *Context) {
		ctx.OSArgs = args
	}
}

func OptionDebug(ctx *Context) {
	ctx.Verbosity = VerbosityDebug
}

func OptionVerbosity(n int) Option {
	return func(ctx *Context) {
		ctx.Verbosity = n
	}
}

func NewContext(bctx build.Context, name string, pkg *build.Package, options ...Option) (ctx Context, err error) {
	config := genieql.MustReadConfiguration(
		genieql.ConfigurationOptionLocation(
			filepath.Join(genieql.ConfigurationDirectory(), name),
		),
	)

	return NewContextFromConfig(bctx, config, pkg, options...)
}

func NewContextFromConfig(bctx build.Context, config genieql.Configuration, pkg *build.Package, options ...Option) (ctx Context, err error) {
	var (
		dialect genieql.Dialect
		driver  genieql.Driver
		mroot   string
	)

	if mroot, err = genieql.FindModuleRoot("."); err != nil {
		return ctx, err
	}

	if dialect, err = dialects.LookupDialect(config); err != nil {
		return ctx, errorsx.Wrap(err, "unable to lookup dialect")
	}

	if driver, err = genieql.LookupDriver(config.Driver); err != nil {
		return ctx, errorsx.Wrap(err, "unable to lookup driver")
	}

	if driver, err = genieql.LoadCustomColumnTypes(config, driver); err != nil {
		return ctx, errorsx.Wrap(err, "unable to load custom types")
	}

	cachedir := userx.DefaultCacheDirectory(md5x.Hex(config.Version, config.Location))
	if err = os.MkdirAll(cachedir, 0700); err != nil {
		return ctx, errorsx.Wrapf(err, "unable to ensure cache directory: %s", cachedir)
	}

	if err = os.MkdirAll(filepath.Join(cachedir, "compiled"), 0700); err != nil {
		return ctx, errorsx.Wrapf(err, "unable to ensure compiled directory: %s", cachedir)
	}

	ctx = Context{
		ModuleRoot:     mroot + "/",
		Name:           config.Name,
		Cache:          cachedir,
		Build:          bctx,
		CurrentPackage: pkg,
		FileSet:        token.NewFileSet(),
		Configuration:  config,
		Dialect:        dialect,
		Driver:         driver,
		OSArgs:         os.Args[1:],
	}

	for _, opt := range options {
		opt(&ctx)
	}

	return ctx, nil
}

func ColumnMapFromFields(ctx Context, inputs ...*ast.Field) (rcmaps []genieql.ColumnMap, err error) {
	typedefs := composeTypeDefinitions(ctx.Driver.LookupType, drivers.DefaultTypeDefinitions)
	for _, input := range inputs {
		for _, name := range input.Names {
			var (
				cmaps []genieql.ColumnMap
			)

			if cd, err := typedefs(types.ExprString(input.Type)); err == nil {
				rcmaps = append(rcmaps, genieql.ColumnMap{
					ColumnInfo: genieql.ColumnInfo{
						Definition: cd,
						Name:       name.String(),
					},
					Dst:   name,
					Field: astutil.Field(input.Type, ast.NewIdent(name.String())),
				})
				continue
			}

			if cmaps, err = MapField(ctx, astutil.Field(input.Type, name)); err != nil {
				return rcmaps, errorsx.Wrapf(
					err,
					"failed to map columns for: %s:%s",
					ctx.CurrentPackage.Name, types.ExprString(input.Type),
				)
			}

			rcmaps = append(rcmaps, cmaps...)
		}
	}

	return rcmaps, nil
}

func ScannerErrorHandling(scanner *ast.FuncDecl) func(local string) ast.Node {
	return func(local string) ast.Node { return astutil.Return(ScannerErrorHandlingExpr(scanner)(local)) }
}

func ScannerErrorHandlingExpr(scanner *ast.FuncDecl, additional ...ast.Expr) func(local string) ast.Expr {
	pattern := astutil.MapFieldsToTypeExpr(scanner.Type.Params.List...)

	if queryPattern(pattern...) {
		return func(local string) ast.Expr {
			return astutil.CallExpr(scanner.Name, ast.NewIdent("nil"), ast.NewIdent(local))
		}
	}

	return func(local string) ast.Expr {
		return astutil.CallExpr(
			&ast.SelectorExpr{
				X:   astutil.CallExpr(scanner.Name, ast.NewIdent("nil")),
				Sel: ast.NewIdent("Err"),
			},
			ast.NewIdent(local),
		)
	}
}

func QueryInputsFromColumnMap(ctx Context, scanner *ast.FuncDecl, errHandler func(string) ast.Node, cmaps ...genieql.ColumnMap) (locals []ast.Spec, encodings []ast.Stmt, qinputs []ast.Expr, err error) {
	if errHandler == nil {
		errHandler = ScannerErrorHandling(scanner)
	}
	encode := ColumnMapEncoder(ctx)

	for idx, cmap := range cmaps {
		var (
			tmp []ast.Stmt
		)

		local := cmap.Local(idx)

		if tmp, err = encode(idx, cmap, errHandler); err != nil {
			return locals, encodings, qinputs, errorsx.Wrap(err, "failed to generate encode")
		}

		if tmp == nil {
			qinputs = append(qinputs, ast.NewIdent(cmap.Name))
			continue
		}

		qinputs = append(qinputs, local)
		encodings = append(encodings, tmp...)

		vspec := astutil.ValueSpec(astutil.MustParseExpr(ctx.FileSet, cmap.Definition.ColumnType), local)
		vspec.Comment = &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Text: "// " + cmap.ColumnInfo.Name,
				},
			},
		}

		locals = append(locals, vspec)
	}

	return locals, encodings, qinputs, nil
}

func QueryFieldsFromColumnMap(ctx Context, cmaps ...genieql.ColumnMap) (locals []*ast.Field) {
	for _, cmap := range cmaps {
		locals = append(locals, cmap.Field)
	}

	return locals
}

// NewFormattedPrinter ensures the generated content is formatted.
func NewFormattedPrinter(d genieql.Generator) Formatting {
	return Formatting{d: d}
}

type Formatting struct {
	d genieql.Generator
}

func (t Formatting) Generate(dst io.Writer) error {
	var (
		err               error
		buffer, formatted bytes.Buffer
	)

	if err = t.d.Generate(&buffer); err != nil {
		return err
	}

	if err = astcodec.FormatOutput(&formatted, buffer.Bytes()); err != nil {
		return errorsx.Wrap(err, buffer.String())
	}

	_, err = io.Copy(dst, &formatted)

	return errorsx.Wrap(err, formatted.String())
}
